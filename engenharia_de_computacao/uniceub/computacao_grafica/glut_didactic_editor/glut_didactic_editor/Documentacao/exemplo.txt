#include <stdio.h>
#include <stdlib.h>
#include <glut.h>

//armazena os vértices de um objeto
struct VERTEX
{
	int x;
	int y;
};

//armazena a descrição geométrica de um objeto
struct OBJECT
{
	VERTEX *vertices;
	int nrvertices;
};

OBJECT *object; //objeto global que será desenhado

OBJECT *create_object()
{
	OBJECT *obj = (OBJECT *)malloc(sizeof(OBJECT));
	obj->nrvertices = 6;
	obj->vertices = (VERTEX *)malloc(obj->nrvertices * sizeof(VERTEX));

	obj->vertices[0].x = 10;
	obj->vertices[0].y = 200;

	obj->vertices[1].x = 40;
	obj->vertices[1].y = 200;

	obj->vertices[2].x = 40;
	obj->vertices[2].y = 50;

	obj->vertices[3].x = 100;
	obj->vertices[3].y = 50;

	obj->vertices[4].x = 100;
	obj->vertices[4].y = 0;

	obj->vertices[5].x = 10;
	obj->vertices[5].y = 0;

	return obj;
}

/*VERTEX calculate_centroid(OBJECT *obj)
{
	int i;
	VERTEX cent;
	cent.x = 0;
	cent.y = 0;

	for (i = 0; i < obj->nrvertices; i++)
	{
		cent.x += obj->vertices[i].x;
		cent.y += obj->vertices[i].y;
	}

	cent.x /= obj->nrvertices;
	cent.y /= obj->nrvertices;
	return cent;
}*/

void init(void)
{
	glClearColor(1.0, 1.0, 1.0, 0.0);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluOrtho2D(-250.0, 250.0, -250.0, 250.0);
	object = create_object(); //cria o objeto
}

void desenha(OBJECT* obj, int opt)
{
	/* opt == Operacoes de transformacao
	* Operacoes na matriz da imagem
	* 0 = Nenhum
	* 1 = Reflexao 0y. Questão 1
	* 2 = Reflexao y = x. QUestao 2
	*/

	int i;
	glBegin(GL_LINE_LOOP); //desenha uma linha

	for (i = 0; i < obj->nrvertices; i++)
	{
		if (opt == 0)
		{
			// Desenha sem alterações
			glVertex2i(obj->vertices[i].x, obj->vertices[i].y);
		}
		if (opt == 1)
		{
			// Reflexao 0y
			glVertex2i(obj->vertices[i].x*-1, obj->vertices[i].y);
		}
		if (opt == 2)
		{
			// Reflexao y=x
			glVertex2i(obj->vertices[i].y, obj->vertices[i].x);
		}

	}

	glEnd();
}

void keyboard(unsigned char key, int x, int y)
{
	if (key == 27)
	{
		if (object != NULL)
		{
			free(object->vertices); //elimina o objeto
			free(object); //elimina o objeto
			exit(1);
		}
	}
}

void display(void)
{
	glClear(GL_COLOR_BUFFER_BIT); //desenha o fundo (limpa a janela)

	glColor3f(1.0, 0.0, 0.0); //altera o atributo de cor
	glMatrixMode(GL_MODELVIEW); //garante que a matrix seja a ModelView

	glPushMatrix();
	desenha(object, 0); //desenha a letra L
	glPopMatrix();

	// Exercicio 1, Reflexao 0y
	glPushMatrix();
	desenha(object, 1);
	glPopMatrix();

	
	glFlush(); //processa as rotinas OpenGL o mais rápido possível
}


int main(int argc, char**argv)
{
	//glutInit(&argc, argv); // glutInit() obrigatorio no Linux
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
	glutInitWindowPosition(100, 100);
	glutInitWindowSize(640, 480);
	glutCreateWindow("William Malvezzi");
	init(); // inicialização (após a criação da janela)
	glutDisplayFunc(display); // registra a função de desenho
	glutKeyboardFunc(keyboard);
	glutMainLoop(); // desenha tudo e espera por eventos
	return EXIT_SUCCESS;
}